<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Quinn</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="quinn.html"><strong aria-hidden="true">1.</strong> QUINN Introduction</a></li><li class="chapter-item expanded "><a href="quic.html"><strong aria-hidden="true">2.</strong> QUICK Introduction</a></li><li class="chapter-item expanded "><a href="protocols/transport-guarantees.html"><strong aria-hidden="true">3.</strong> Protocols</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="protocols/transport-guarantees.html"><strong aria-hidden="true">3.1.</strong> Transport Guarantees</a></li><li class="chapter-item expanded "><a href="protocols/transport-protocols.html"><strong aria-hidden="true">3.2.</strong> Transport Protocols</a></li><li class="chapter-item expanded "><a href="protocols/tcp-problems.html"><strong aria-hidden="true">3.3.</strong> Problems of TCP</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Quinn</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#quinn" id="quinn">Quinn</a></h1>
<p><a href="https://docs.rs/quinn/"><img src="https://docs.rs/quinn/badge.svg" alt="Documentation" /></a>
<a href="https://crates.io/crates/quinn"><img src="https://img.shields.io/crates/v/quinn.svg" alt="Crates.io" /></a>
<a href="https://github.com/djc/quinn/actions?query=workflow%3ACI"><img src="https://github.com/djc/quinn/workflows/CI/badge.svg" alt="Build status" /></a>
<a href="https://codecov.io/gh/djc/quinn"><img src="https://codecov.io/gh/djc/quinn/branch/master/graph/badge.svg" alt="codecov" /></a>
<a href="https://matrix.to/#/#quinn:matrix.org"><img src="https://img.shields.io/badge/chat-%23quinn:matrix.org-%2346BC99?logo=matrix" alt="Chat" /></a>
<a href="https://gitter.im/djc/quinn"><img src="https://badges.gitter.im/gitterHQ/gitter.svg" alt="Chat" /></a>
<a href="LICENSE-MIT"><img src="https://img.shields.io/badge/License-MIT-blue.svg" alt="License: MIT" /></a>
<a href="LICENSE-APACHE"><img src="https://img.shields.io/badge/License-Apache%202.0-blue.svg" alt="License: Apache 2.0" /></a></p>
<p>Quinn is an implementation of the <a href="https://quicwg.github.io/">QUIC</a> transport protocol undergoing
standardization by the IETF. It is suitable for experimental use. This repository
contains the following crates:</p>
<ul>
<li><code>quinn</code> contains a high-level async API based on tokio, see
<a href="https://github.com/djc/quinn/tree/master/quinn/examples">quinn/examples/</a> for
usage. This will be used by most Rust developers. (Basic benchmarks are included.)</li>
<li><code>quinn-proto</code> contains a deterministic state machine of the protocol which performs
no I/O internally and is suitable for use with custom event loops (and potentially
a C or C++ API).</li>
<li><code>quinn-h3</code> contains an implementation of HTTP 3 and QPACK. It is split internally
in a deterministatic state machine and a tokio-based high-level async API.</li>
<li><code>bench</code> contains some extra benchmarks without any framework.</li>
<li><code>interop</code> contains tooling that helps the Quinn team run interoperability tests.</li>
</ul>
<p>Quinn is the subject of a <a href="https://paris.rustfest.eu/sessions/a-quic-future-in-rust">RustFest Paris (May 2018) presentation</a>; you can
also get the <a href="https://dirkjan.ochtman.nl/files/quic-future-in-rust.pdf">slides</a> (and the <a href="https://dirkjan.ochtman.nl/files/head-of-line-blocking.html">animation</a> about head-of-line
blocking). Video of the talk is available <a href="https://www.youtube.com/watch?v=EHgyY5DNdvI">on YouTube</a>. Since this
presentation, Quinn has been merged with quicr, another Rust implementation.</p>
<p>All feedback welcome. Feel free to file bugs, requests for documentation and
any other feedback to the <a href="https://github.com/djc/quinn/issues">issue tracker</a>.</p>
<p>Quinn was created and is maintained by Dirkjan Ochtman and Benjamin Saunders.</p>
<h2><a class="header" href="#features" id="features">Features</a></h2>
<ul>
<li>Simultaneous client/server operation</li>
<li>Ordered and unordered stream reads for improved performance</li>
<li>Works on stable Rust, tested on Linux, macOS and Windows</li>
<li>Pluggable cryptography, with a standard implementation backed by
<a href="https://github.com/ctz/rustls">rustls</a> and <a href="https://github.com/briansmith/ring"><em>ring</em></a></li>
<li>Application-layer datagrams for small, unreliable messages</li>
</ul>
<h2><a class="header" href="#status" id="status">Status</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
QUIC draft 27 with TLS 1.3</li>
<li><input disabled="" type="checkbox" checked=""/>
Cryptographic handshake</li>
<li><input disabled="" type="checkbox" checked=""/>
Stream data w/ flow control and congestion control</li>
<li><input disabled="" type="checkbox" checked=""/>
Connection close</li>
<li><input disabled="" type="checkbox" checked=""/>
Stateless retry</li>
<li><input disabled="" type="checkbox" checked=""/>
Explicit congestion notification</li>
<li><input disabled="" type="checkbox" checked=""/>
Migration</li>
<li><input disabled="" type="checkbox" checked=""/>
0-RTT data</li>
<li><input disabled="" type="checkbox" checked=""/>
Session resumption</li>
<li><input disabled="" type="checkbox"/>
HTTP over QUIC</li>
</ul>
<h2><a class="header" href="#usage-notes" id="usage-notes">Usage Notes</a></h2>
<h3><a class="header" href="#buffers" id="buffers">Buffers</a></h3>
<p>A Quinn endpoint corresponds to a single UDP socket, no matter how many
connections are in use. Handling high aggregate data rates on a single endpoint
can require a larger UDP buffer than is configured by default in most
environments. If you observe erratic latency and/or throughput over a stable
network link, consider increasing the buffer sizes used. For example, you could
adjust the <code>SO_SNDBUF</code> and <code>SO_RCVBUF</code> options of the UDP socket to be used
before passing it in to Quinn. Note that some platforms (e.g. Linux) require
elevated privileges or modified system configuration for a process to increase
its UDP buffer sizes.</p>
<h3><a class="header" href="#certificates" id="certificates">Certificates</a></h3>
<p>By default, Quinn clients validate the cryptographic identity of servers they
connect to. This prevents an active, on-path attacker from intercepting
messages, but requires trusting some certificate authority. For many purposes,
this can be accomplished by using certificates from <a href="https://letsencrypt.org/">Let's Encrypt</a>
for servers, and relying on the default configuration for clients.</p>
<p>For some cases, including peer-to-peer, trust-on-first-use, deliberately
insecure applications, or any case where servers are not identified by domain
name, this isn't practical. Arbitrary certificate validation logic can be
implemented by enabling the <code>dangerous_configuration</code> feature of <code>rustls</code> and
constructing a Quinn <code>ClientConfig</code> with an overridden certificate verifier by
hand.</p>
<p>When operating your own certificate authority doesn't make sense, <a href="https://crates.io/crates/rcgen">rcgen</a>
can be used to generate self-signed certificates on demand. To support
trust-on-first-use, servers that automatically generate self-signed certificates
should write their generated certificate to persistent storage and reuse it on
future runs.</p>
<h2><a class="header" href="#running-the-examples" id="running-the-examples">Running the Examples</a></h2>
<pre><code class="language-sh">$ cargo run --example server ./
$ cargo run --example client https://localhost:4433/Cargo.toml
</code></pre>
<p>This launches a HTTP 0.9 server on the loopback address serving the current
working directory, with the client fetching <code>./Cargo.toml</code>. By default, the
server generates a self-signed certificate and stores it to disk, where the
client will automatically find and trust it.</p>
<h2><a class="header" href="#development" id="development">Development</a></h2>
<p>The quinn-proto test suite uses simulated IO for reproducibility and to avoid
long sleeps in certain timing-sensitive tests. If the <code>SSLKEYLOGFILE</code>
environment variable is set, the tests will emit UDP packets for inspection
using external protocol analyzers like Wireshark, and NSS-compatible key logs
for the client side of each connection will be written to the path specified in
the variable.</p>
<h1><a class="header" href="#quic-introduction" id="quic-introduction">QUIC Introduction</a></h1>
<p>QUIC is a general-purpose, transport layer, network protocol, built on top of UDP.
It is still an internet <a href="https://datatracker.ietf.org/doc/draft-ietf-quic-transport/">draft</a> undergoing standardization by the IETF.
This indicates that it is not yet stabilized. 
Quinn focuses on satisfying the latest draft but may lag some drafts behind. 
The fact that it is a draft does not detract from the fact that QUIC is already used by more than half of 
all connections from Chrome web browsers to Google's servers with increasing adoption in the overall market. </p>
<p>QUIC aims to be nearly equivalent to a TCP connection. With the goals to improve the performance of connection-oriented web applications, 
reduce connection and transport latency, and estimate bandwidth for better congestion control. 
While the intentions of QUIC were original web-oriented, it suits other areas like the game-networking industry very well.</p>
<p>Before diving into any protocol specifics, lets define what we mean by terminology that is often used while talking about protocols.
The protocols that we will be discussing share some combinations of grantees notes on this page. 
In your protocol selection for the right protocol you must clearly have in mind what it is for combination that you need.</p>
<h2><a class="header" href="#ordering-vs-sequencing" id="ordering-vs-sequencing">Ordering VS Sequencing</a></h2>
<p>Let's define two concepts here:
<em>&quot;Sequencing: this is the process of only caring about the newest items.&quot;</em> <a href="https://dictionary.cambridge.org/dictionary/english/sequencing">1</a>
<em>&quot;Ordering: this is the process of putting something in a particular order.&quot;</em> <a href="https://dictionary.cambridge.org/dictionary/english/ordering">2</a></p>
<ul>
<li>Sequencing: Only the newest items will be passed trough e.g. <code>1,3,2,5,4</code> which results in <code>1,3,5</code>.</li>
<li>Ordering: All items are returned in order <code>1,3,2,5,4</code> which results in <code>1,2,3,4,5</code>.</li>
</ul>
<p>Now, lets discuss those different transport guarantees a protocol can have. </p>
<h2><a class="header" href="#the-5-reliability-guarantees" id="the-5-reliability-guarantees">The 5 Reliability Guarantees</a></h2>
<p>There are 5 different ways you can transfer data:</p>
<table><thead><tr><th align="center">Reliability Type</th><th align="center">Packet Drop</th><th align="center">Packet Duplication</th><th align="center">Packet Order</th><th align="center">Packet Delivery</th></tr></thead><tbody>
<tr><td align="center"><strong>Unreliable Unordered</strong></td><td align="center">Any</td><td align="center">Yes</td><td align="center">No</td><td align="center">No</td></tr>
<tr><td align="center"><strong>Unreliable Sequenced</strong></td><td align="center">Any + old</td><td align="center">No</td><td align="center">Sequenced</td><td align="center">No</td></tr>
<tr><td align="center"><strong>Reliable Unordered</strong></td><td align="center">No</td><td align="center">No</td><td align="center">No</td><td align="center">Yes</td></tr>
<tr><td align="center"><strong>Reliable Ordered</strong></td><td align="center">No</td><td align="center">No</td><td align="center">Ordered</td><td align="center">Yes</td></tr>
<tr><td align="center"><strong>Reliable Sequenced</strong></td><td align="center">Only old</td><td align="center">No</td><td align="center">Sequenced</td><td align="center">Only newest</td></tr>
</tbody></table>
<h3><a class="header" href="#unreliable" id="unreliable">Unreliable</a></h3>
<p>Unreliable: Packets can be dropped, duplicated or arrive in any order.</p>
<p><strong>Details</strong></p>
<table><thead><tr><th align="center">Packet Drop</th><th align="center">Packet Duplication</th><th align="center">Packet Order</th><th align="center">Packet Delivery</th></tr></thead><tbody>
<tr><td align="center">Any</td><td align="center">Yes</td><td align="center">No</td><td align="center">No</td></tr>
</tbody></table>
<p>Basically just bare UDP. The packet may or may not be delivered.</p>
<h3><a class="header" href="#unreliable-sequenced" id="unreliable-sequenced">Unreliable Sequenced</a></h3>
<p>Unreliable Sequenced: Packets can be dropped, but could not be duplicated and arrive in sequence.</p>
<p><em>Details</em></p>
<table><thead><tr><th align="center">Packet Drop</th><th align="center">Packet Duplication</th><th align="center">Packet Order</th><th align="center">Packet Delivery</th></tr></thead><tbody>
<tr><td align="center">Any + old</td><td align="center">No</td><td align="center">Sequenced</td><td align="center">No</td></tr>
</tbody></table>
<p>Basically just bare UDP, free to be dropped, but has some sequencing to it so that only the newest packets are kept.</p>
<h3><a class="header" href="#reliable-unordered" id="reliable-unordered">Reliable Unordered</a></h3>
<p>Reliable UnOrder: All packets will be sent and received, but without order.</p>
<p><em>Details</em></p>
<table><thead><tr><th align="center">Packet Drop</th><th align="center">Packet Duplication</th><th align="center">Packet Order</th><th align="center">Packet Delivery</th></tr></thead><tbody>
<tr><td align="center">No</td><td align="center">No</td><td align="center">No</td><td align="center">Yes</td></tr>
</tbody></table>
<p>Basically, this is almost TCP without ordering of packets.</p>
<h3><a class="header" href="#reliable-ordered" id="reliable-ordered">Reliable Ordered</a></h3>
<p>Reliable Unordered: All packets will be sent and received, but in the order in which they arrived.</p>
<p><em>Details</em></p>
<table><thead><tr><th align="center">Packet Drop</th><th align="center">Packet Duplication</th><th align="center">Packet Order</th><th align="center">Packet Delivery</th></tr></thead><tbody>
<tr><td align="center">No</td><td align="center">No</td><td align="center">Ordered</td><td align="center">Yes</td></tr>
</tbody></table>
<p>Basically this is almost like TCP.</p>
<h3><a class="header" href="#reliable-sequenced" id="reliable-sequenced">Reliable Sequenced</a></h3>
<p>Reliable; All packets will be sent and received but arranged in sequence.
Which means that only the newest packets will be let through, older packets will be received but they won't get to the user.</p>
<p><em>Details</em></p>
<table><thead><tr><th align="center">Packet Drop</th><th align="center">Packet Duplication</th><th align="center">Packet Order</th><th align="center">Packet Delivery</th></tr></thead><tbody>
<tr><td align="center">Only old</td><td align="center">No</td><td align="center">Sequenced</td><td align="center">Only newest</td></tr>
</tbody></table>
<p>Basically this is almost TCP-like but then sequencing instead of ordering.</p>
<p>Before diving into any protocol specifics, lets define what we mean by terminology that is often used while talking about protocols.
The protocols that we will be discussing share some combinations of grantees notes on this page. 
In your protocol selection for the right protocol you must clearly have in mind what it is for combination that you need.</p>
<h2><a class="header" href="#ordering-vs-sequencing-1" id="ordering-vs-sequencing-1">Ordering VS Sequencing</a></h2>
<p>Let's define two concepts here:
<em>&quot;Sequencing: this is the process of only caring about the newest items.&quot;</em> <a href="https://dictionary.cambridge.org/dictionary/english/sequencing">1</a>
<em>&quot;Ordering: this is the process of putting something in a particular order.&quot;</em> <a href="https://dictionary.cambridge.org/dictionary/english/ordering">2</a></p>
<ul>
<li>Sequencing: Only the newest items will be passed trough e.g. <code>1,3,2,5,4</code> which results in <code>1,3,5</code>.</li>
<li>Ordering: All items are returned in order <code>1,3,2,5,4</code> which results in <code>1,2,3,4,5</code>.</li>
</ul>
<p>Now, lets discuss those different transport guarantees a protocol can have. </p>
<h2><a class="header" href="#the-5-reliability-guarantees-1" id="the-5-reliability-guarantees-1">The 5 Reliability Guarantees</a></h2>
<p>There are 5 different ways you can transfer data:</p>
<table><thead><tr><th align="center">Reliability Type</th><th align="center">Packet Drop</th><th align="center">Packet Duplication</th><th align="center">Packet Order</th><th align="center">Packet Delivery</th></tr></thead><tbody>
<tr><td align="center"><strong>Unreliable Unordered</strong></td><td align="center">Any</td><td align="center">Yes</td><td align="center">No</td><td align="center">No</td></tr>
<tr><td align="center"><strong>Unreliable Sequenced</strong></td><td align="center">Any + old</td><td align="center">No</td><td align="center">Sequenced</td><td align="center">No</td></tr>
<tr><td align="center"><strong>Reliable Unordered</strong></td><td align="center">No</td><td align="center">No</td><td align="center">No</td><td align="center">Yes</td></tr>
<tr><td align="center"><strong>Reliable Ordered</strong></td><td align="center">No</td><td align="center">No</td><td align="center">Ordered</td><td align="center">Yes</td></tr>
<tr><td align="center"><strong>Reliable Sequenced</strong></td><td align="center">Only old</td><td align="center">No</td><td align="center">Sequenced</td><td align="center">Only newest</td></tr>
</tbody></table>
<h3><a class="header" href="#unreliable-1" id="unreliable-1">Unreliable</a></h3>
<p>Unreliable: Packets can be dropped, duplicated or arrive in any order.</p>
<p><strong>Details</strong></p>
<table><thead><tr><th align="center">Packet Drop</th><th align="center">Packet Duplication</th><th align="center">Packet Order</th><th align="center">Packet Delivery</th></tr></thead><tbody>
<tr><td align="center">Any</td><td align="center">Yes</td><td align="center">No</td><td align="center">No</td></tr>
</tbody></table>
<p>Basically just bare UDP. The packet may or may not be delivered.</p>
<h3><a class="header" href="#unreliable-sequenced-1" id="unreliable-sequenced-1">Unreliable Sequenced</a></h3>
<p>Unreliable Sequenced: Packets can be dropped, but could not be duplicated and arrive in sequence.</p>
<p><em>Details</em></p>
<table><thead><tr><th align="center">Packet Drop</th><th align="center">Packet Duplication</th><th align="center">Packet Order</th><th align="center">Packet Delivery</th></tr></thead><tbody>
<tr><td align="center">Any + old</td><td align="center">No</td><td align="center">Sequenced</td><td align="center">No</td></tr>
</tbody></table>
<p>Basically just bare UDP, free to be dropped, but has some sequencing to it so that only the newest packets are kept.</p>
<h3><a class="header" href="#reliable-unordered-1" id="reliable-unordered-1">Reliable Unordered</a></h3>
<p>Reliable UnOrder: All packets will be sent and received, but without order.</p>
<p><em>Details</em></p>
<table><thead><tr><th align="center">Packet Drop</th><th align="center">Packet Duplication</th><th align="center">Packet Order</th><th align="center">Packet Delivery</th></tr></thead><tbody>
<tr><td align="center">No</td><td align="center">No</td><td align="center">No</td><td align="center">Yes</td></tr>
</tbody></table>
<p>Basically, this is almost TCP without ordering of packets.</p>
<h3><a class="header" href="#reliable-ordered-1" id="reliable-ordered-1">Reliable Ordered</a></h3>
<p>Reliable Unordered: All packets will be sent and received, but in the order in which they arrived.</p>
<p><em>Details</em></p>
<table><thead><tr><th align="center">Packet Drop</th><th align="center">Packet Duplication</th><th align="center">Packet Order</th><th align="center">Packet Delivery</th></tr></thead><tbody>
<tr><td align="center">No</td><td align="center">No</td><td align="center">Ordered</td><td align="center">Yes</td></tr>
</tbody></table>
<p>Basically this is almost like TCP.</p>
<h3><a class="header" href="#reliable-sequenced-1" id="reliable-sequenced-1">Reliable Sequenced</a></h3>
<p>Reliable; All packets will be sent and received but arranged in sequence.
Which means that only the newest packets will be let through, older packets will be received but they won't get to the user.</p>
<p><em>Details</em></p>
<table><thead><tr><th align="center">Packet Drop</th><th align="center">Packet Duplication</th><th align="center">Packet Order</th><th align="center">Packet Delivery</th></tr></thead><tbody>
<tr><td align="center">Only old</td><td align="center">No</td><td align="center">Sequenced</td><td align="center">Only newest</td></tr>
</tbody></table>
<p>Basically this is almost TCP-like but then sequencing instead of ordering.</p>
<h1><a class="header" href="#networking-protocols" id="networking-protocols">Networking protocols</a></h1>
<p>The internet is unreliable, internet is changing every second, cables could be cut, congestion on the network can defer etc. 
Once we send any package it could take any path to eventually arrive at its destination. </p>
<p>It is an excellent question to ask what protocol suits your project the most. 
Different protocols serve different use cases and the wrong protocol can be catastrophic. 
Before jumping directly into the meat of QUIC, it can be usefull to understand its underlying motivations. 
For those motivations we have to inspect the flaws of TCP and nature of UDP.</p>
<p>If your already familiar with terminologies as IP/TCP/UDP and their guarantees and differences feel free to skipp to this section. 
For this section we will be using the [Internet protocol suite][internet-protocol-suite] as a guidance. </p>
<p><img src="protocols/../../images/osi-model.png" alt="OSI model" /></p>
<h2><a class="header" href="#ip----internet-layer" id="ip----internet-layer">IP  - Internet layer</a></h2>
<p>All communication over the internet is happening ontop of IP (Internet Protocol). 
The internet protocol works by splitting data into little chunks called datagrams or packets. 
The chunks are then sent across the internet from one IP address to another.
However, this protocol transfers packets across the network without any guarantee and it is by nature <a href="protocols/./transport-guarantees.html#unreliable">unreliable</a>.
For certain applications, we need certain specific guarantees. 
This is exactly were transport protocols, like TCP, UPD, and application protocols, like QUIC, HTTP, come in. </p>
<h2><a class="header" href="#tcpip-and-udp-comparison---transport-layer" id="tcpip-and-udp-comparison---transport-layer">TCP/IP and UDP comparison - Transport layer</a></h2>
<p><strong>TCP:</strong> stands for 'transmission control protocol' and adds certain guarantees ontop of <a href="protocols/transport-protocols.html#ip">IP</a>. 
It forms the backbone for almost everything you do online, from web browsing to IRC to email to file transfer, it’s all built on top of TCP/IP.</p>
<p><strong>UDP</strong> stands for 'user datagram protocol' and it’s another protocol built on top of IP, but unlike TCP, 
instead of adding lots of features and complexity, UDP is a very thin layer over IP and is <a href="protocols/./transport-guarantees.html#unreliable">unreliable</a> in nature.</p>
<table><thead><tr><th align="center">Feature</th><th align="center">TCP</th><th align="center">UDP</th></tr></thead><tbody>
<tr><td align="center"><a href="https://en.wikipedia.org/wiki/Connection-oriented_communication">Connection-Oriented</a></td><td align="center">Yes</td><td align="center">No</td></tr>
<tr><td align="center">Reliability Guarantees</td><td align="center"><a href="protocols/./transport-guarantees.html#reliable-ordered">Reliable Ordered</a></td><td align="center"><a href="protocols/./transport-guarantees.html#unreliable">Unreliable</a></td></tr>
<tr><td align="center">Packet Transfer</td><td align="center"><a href="https://en.wikipedia.org/wiki/Stream_(computing)">Stream-based</a></td><td align="center">Message based</td></tr>
<tr><td align="center">Automatic <a href="https://en.wikipedia.org/wiki/IP_fragmentation">fragmentation</a></td><td align="center">Yes</td><td align="center">Yes, but better is to stay below datagram size limit</td></tr>
<tr><td align="center">Header Size</td><td align="center">20 bytes</td><td align="center">8 bytes</td></tr>
<tr><td align="center"><a href="https://en.wikipedia.org/wiki/TCP_congestion_control">Control Flow, Congestion Avoidance/Control</a></td><td align="center">Yes</td><td align="center">No</td></tr>
</tbody></table>
<h1><a class="header" href="#problems-of-tcp" id="problems-of-tcp">Problems of TCP</a></h1>
<p>In <a href="protocols/./transport-protocols.html">the previous section</a> we compared TCP with UDP, now the golden question: Why should we prefer one over the other? 
One might ask: &quot;Why choose so much uncertainty with UDP when TCP is so reliable and safe?&quot;. 
That's a good question to ask yourself. 
To answer that question we will have to delve a little deeper into how TCP works. </p>
<h2><a class="header" href="#head-of-line-blocking" id="head-of-line-blocking">Head-of-line blocking</a></h2>
<p>One of the biggest problem/feature in the TCP protocol is the Head-of-line blocking. 
It is a convenient feature because it ensures that all packages are sent in <a href="protocols/./transport-guarantees.html#ordering-vs-sequencing">order</a>. 
However, in areas of high throughput this can cause problems.<br />
One of those areas is a multiplayer fast-phases FPS game.</p>
<p>Lets check this animation out <a href="https://dirkjan.ochtman.nl/files/head-of-line-blocking.html">animation</a> to demonstrate the issue that we are facing.<br />
This animation shows that if a certain packet drops in transmission, all packets have to wait before it is resent and acknowledged by the other end.</p>
<p>Multiplayer action games are based on a constant stream of packets sent at a speed of 10 to 30 packets per second, and for the most part, 
the data in these packages are so time-sensitive that in most cases only the most recent data is useful.
You can think of the input of the player, the position of the player, the orientation and speed, and the state of the physical objects in the world.</p>
<p>Take, for example, a scenario in which 30 packets per second are sent with player positions.
If a single packet drops, we should ignore it and look for the next packet with player input that arrives 2 milliseconds later, we only care about the latest input, right?
But with TCP if there is a latency of 100 milliseconds and a single packet drops all packets sent during the retransmission (retransmission request (100 ms) + retransmission (100 ms)) will be queued until the lost packet is retransmitted. 
After 200ms this would mean 100 packets (200/2) are queue. 
A fast phased game can not afford those numbers. </p>
<p>Gamenetworking is not the only area were this head-of-line blocking plays creates some problems. 
HTTP-2 uses multiplexing to attack this issue. </p>
<p><strong>Solutions</strong></p>
<p>There are various solutions that fix this head-of-line blocking problem. </p>
<ul>
<li>Multiplexing</li>
<li>Rebuild a variation of TCP ontop of UDP (laminar, networksockets, netcode)</li>
</ul>
<p>QUIC uses both multiplexing but also rebuild a reliability layer ontop of UDP. </p>
<h2><a class="header" href="#connection-setup" id="connection-setup">Connection Setup</a></h2>
<p>In standard HTTP+TLS+TCP, TCP needs a handshake to establish a session between server and client, and TLS needs its own handshake to ensure that the session is secured.</p>
<p><img src="protocols/../../images/tcp-handshake.svg.png" alt="TCP-handshake" /></p>
<p>First, the source sends an SYN “initial request” packet to the target server in order to start the dialogue. 
Then the target server then sends a SYN-ACK packet to agree to the process.
Lastly, the source sends an ACK packet to the target to confirm the process, after which the message contents can be sent. </p>
<p>Now if we want to secure the TCP connection, we have to use TLS on top of that. If we use an older TLS version then 1.3 then there are three more handshakes that are required.</p>
<p>You can see how expensive it is to create a TCP connection. In a scenario of TCP and TLS 1.2 with a 100ms latancy we need to wait 6 x 100ms = 600ms for our website to be able to load. 
If the website is big in size, then an additional load time can bring the load time over one second. Which is of course disturbing for our short attention spans. </p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
